# Pentesting
Videos/Codes from the pentesting class

This project sets up a basic Flask application with MySQL database integration using Docker containers, allowing users to query the database through a web interface. This project is set to execute SQL injection within a Flask and Docker container environment. The vulnerability stems from the lack of proper validation and parameterization in constructing SQL queries based on user input. By directly inserting user-supplied data into the SQL query string, the application becomes susceptible to injection attacks, where malicious input can manipulate the query's logic. To address this vulnerability, it's imperative to implement security measures such as parameterized queries or prepared statements, which isolate user input from SQL code execution and enhance the overall security posture of the application.

Similarly, The project also is designed to demonstrate a scenario involving command injection vulnerability within a Flask web application running in a Docker container. Let's break down the components and the flow:

### Components:

1. **Flask Application**: The Flask application serves as the web server handling HTTP requests. It exposes a single route ('/') which accepts a query parameter named 'address'. The address is expected to be an IP address or a hostname. The function `hello()` is responsible for processing the request and invoking the `ping()` function.

2. **Ping Functionality**: The `ping()` function is intended to execute the system ping command using the subprocess module in Python. It constructs a shell command to ping the provided address (`ping -c 1 <address>`) and returns the output of the command.

3. **Command Line Argument Parser**: The `argparse` module is used to parse command-line arguments. However, in the current implementation, it doesn't accept any arguments.

4. **Docker Configuration**: The Dockerfile specifies the Docker configuration. It installs the necessary Python dependencies listed in `requirements.txt` and copies the current directory contents into the Docker container. Finally, it specifies the command to execute the Flask application (`CMD [ "python3", "main.py"]`).

### Vulnerability:

The vulnerability lies in the way the `ping()` function is constructed. It directly takes the user input (the address parameter from the HTTP request) and constructs a shell command without proper input validation or sanitization.

An attacker can exploit this vulnerability by injecting arbitrary shell commands into the 'address' query parameter of the HTTP request. The semi-colon (`;`) is used as a command separator in Unix-like systems, allowing multiple commands to be executed sequentially. 

For instance, an attacker can append arbitrary commands after the valid IP address like `127.0.0.1;ls` or `127.0.0.1;pwd`. When the server processes such requests, it executes these additional commands alongside the legitimate ping command, leading to command injection.

### Conclusion:

In summary, this project illustrates a command injection vulnerability within a Flask application running in a Docker container. It emphasizes the importance of input validation and sanitization, especially when dealing with user-supplied data in web applications, to prevent such security risks.
